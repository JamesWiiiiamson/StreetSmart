/**
 * Heatmap utilities for crime density-based routing
 * Processes crime data into a grid-based safety map
 */

export interface GridCell {
  latMin: number;
  latMax: number;
  lngMin: number;
  lngMax: number;
  crimeCount: number;
  safetyScore: number; // 0-100, higher is safer
  color: string;
  opacity: number; // Fill opacity matching create_grid_map.py
  percentile: number;
}

export interface HeatmapData {
  gridSize: number;
  cells: GridCell[];
  bounds: {
    latMin: number;
    latMax: number;
    lngMin: number;
    lngMax: number;
  };
  percentiles?: number[];
  totalCrimes?: number;
}

export interface LightingGridCell {
  latMin: number;
  latMax: number;
  lngMin: number;
  lngMax: number;
  lightCount: number;
  lightingScore: number; // 0-100, higher is better lit
  color: string;
  opacity: number;
  percentile: number;
}

export interface LightingHeatmapData {
  gridSize: number;
  cells: LightingGridCell[];
  bounds: {
    latMin: number;
    latMax: number;
    lngMin: number;
    lngMax: number;
  };
  percentiles?: number[];
  totalLights?: number;
}

// Color mapping based on percentile (from create_grid_map.py)
// Enhanced scoring to create more differentiation between safest and worst routes
const COLOR_MAP = [
  { maxPercentile: 10, color: '#FFFFCC', safetyScore: 100 }, // Very light yellow (safest) - increased from 95
  { maxPercentile: 20, color: '#FFFF99', safetyScore: 92 }, // Increased from 90
  { maxPercentile: 30, color: '#FFFF66', safetyScore: 85 }, // Same
  { maxPercentile: 40, color: '#FFED4E', safetyScore: 75 }, // Decreased from 80
  { maxPercentile: 50, color: '#FFDB4D', safetyScore: 65 }, // Decreased from 75
  { maxPercentile: 60, color: '#FFC04D', safetyScore: 55 }, // Decreased from 70
  { maxPercentile: 70, color: '#FF9933', safetyScore: 40 }, // Decreased from 60
  { maxPercentile: 80, color: '#FF6B1A', safetyScore: 25 }, // Decreased from 45
  { maxPercentile: 90, color: '#FF3300', safetyScore: 12 }, // Decreased from 30
  { maxPercentile: 100, color: '#CC0000', safetyScore: 5 }, // Dark red (most dangerous) - decreased from 10
];

/**
 * Get color and safety score based on percentile
 */
export const getSafetyColor = (percentile: number): { color: string; safetyScore: number } => {
  for (const range of COLOR_MAP) {
    if (percentile <= range.maxPercentile) {
      return { color: range.color, safetyScore: range.safetyScore };
    }
  }
  return { color: COLOR_MAP[COLOR_MAP.length - 1].color, safetyScore: COLOR_MAP[COLOR_MAP.length - 1].safetyScore };
};

/**
 * Load pre-processed heatmap grid data
 * This data should be generated by running: node src/lib/processHeatmapData.js
 * Which processes the CSV using the exact same logic as create_grid_map.py
 */
export const processCrimeDataToGrid = async (): Promise<HeatmapData> => {
  try {
    // Try to load pre-processed heatmap grid data first
    const response = await fetch('/data/heatmap-grid.json');
    if (response.ok) {
      const data = await response.json();
      // Add safety scores to cells if not present
      const cellsWithScores: GridCell[] = data.cells.map((cell: any) => {
        const { color, safetyScore } = getSafetyColor(cell.percentile);
        return {
          ...cell,
          safetyScore: cell.safetyScore || safetyScore,
          opacity: cell.opacity || 0.4, // Default opacity if not in data
        };
      });
      return {
        ...data,
        cells: cellsWithScores,
      };
    }
  } catch (error) {
    console.warn('Could not load heatmap-grid.json, falling back to processing crime-data.json:', error);
  }

  // Fallback: process from crime-data.json (less accurate but works)
  const gridSize = 0.005; // Same as create_grid_map.py
  const latMin = 43.58;
  const latMax = 43.85;
  const lngMin = -79.64;
  const lngMax = -79.12;

  try {
    const response = await fetch('/data/crime-data.json');
    const crimeData = await response.json();
    
    // Count crimes per cell
    const cellCounts: Map<string, number> = new Map();
    
    crimeData.forEach((crime: any) => {
      if (crime.lat && crime.lng) {
        const latBin = Math.floor((crime.lat - latMin) / gridSize);
        const lngBin = Math.floor((crime.lng - lngMin) / gridSize);
        const key = `${latBin}_${lngBin}`;
        cellCounts.set(key, (cellCounts.get(key) || 0) + 1);
      }
    });

    // Calculate percentiles
    const counts = Array.from(cellCounts.values());
    const sortedCounts = [...counts].sort((a, b) => a - b);
    const percentiles = [
      sortedCounts[Math.floor(sortedCounts.length * 0.1)] || 0,
      sortedCounts[Math.floor(sortedCounts.length * 0.2)] || 0,
      sortedCounts[Math.floor(sortedCounts.length * 0.3)] || 0,
      sortedCounts[Math.floor(sortedCounts.length * 0.4)] || 0,
      sortedCounts[Math.floor(sortedCounts.length * 0.5)] || 0,
      sortedCounts[Math.floor(sortedCounts.length * 0.6)] || 0,
      sortedCounts[Math.floor(sortedCounts.length * 0.7)] || 0,
      sortedCounts[Math.floor(sortedCounts.length * 0.8)] || 0,
      sortedCounts[Math.floor(sortedCounts.length * 0.9)] || 0,
      sortedCounts[sortedCounts.length - 1] || 0,
    ];

    // Create grid cells with exact colors/opacity from create_grid_map.py
    const cells: GridCell[] = [];
    
    cellCounts.forEach((count, key) => {
      const [latBin, lngBin] = key.split('_').map(Number);
      const latStart = latMin + latBin * gridSize;
      const latEnd = latStart + gridSize;
      const lngStart = lngMin + lngBin * gridSize;
      const lngEnd = lngStart + gridSize;

      // Calculate percentile and get color/opacity (exact match from create_grid_map.py)
      let percentile = 0;
      for (let i = 0; i < percentiles.length; i++) {
        if (count <= percentiles[i]) {
          percentile = (i + 1) * 10;
          break;
        }
      }
      if (percentile === 0) percentile = 100;

      // Get color and opacity matching create_grid_map.py exactly
      let color = '#FFFFCC';
      let opacity = 0.4;
      if (count <= percentiles[0]) { color = '#FFFFCC'; opacity = 0.4; }
      else if (count <= percentiles[1]) { color = '#FFFF99'; opacity = 0.45; }
      else if (count <= percentiles[2]) { color = '#FFFF66'; opacity = 0.5; }
      else if (count <= percentiles[3]) { color = '#FFED4E'; opacity = 0.55; }
      else if (count <= percentiles[4]) { color = '#FFDB4D'; opacity = 0.6; }
      else if (count <= percentiles[5]) { color = '#FFC04D'; opacity = 0.65; }
      else if (count <= percentiles[6]) { color = '#FF9933'; opacity = 0.7; }
      else if (count <= percentiles[7]) { color = '#FF6B1A'; opacity = 0.75; }
      else if (count <= percentiles[8]) { color = '#FF3300'; opacity = 0.8; }
      else { color = '#CC0000'; opacity = 0.85; }

      const { safetyScore } = getSafetyColor(percentile);

      cells.push({
        latMin: latStart,
        latMax: latEnd,
        lngMin: lngStart,
        lngMax: lngEnd,
        crimeCount: count,
        safetyScore,
        color,
        opacity,
        percentile,
      });
    });

    return {
      gridSize,
      cells,
      bounds: { latMin, latMax, lngMin, lngMax },
      percentiles,
      totalCrimes: crimeData.length,
    };
  } catch (error) {
    console.error('Error loading crime data:', error);
    // Return empty grid
    return {
      gridSize,
      cells: [],
      bounds: { latMin, latMax, lngMin, lngMax },
    };
  }
};

/**
 * Get safety score for a specific lat/lng coordinate
 */
export const getSafetyScoreAtLocation = (
  lat: number,
  lng: number,
  heatmapData: HeatmapData
): number => {
  const cell = heatmapData.cells.find(
    (c) =>
      lat >= c.latMin &&
      lat < c.latMax &&
      lng >= c.lngMin &&
      lng < c.lngMax
  );
  
  return cell?.safetyScore ?? 50; // Default to medium safety if not found
};

/**
 * Get safety score along a route path
 */
export const getRouteSafetyScore = (
  path: google.maps.LatLng[],
  heatmapData: HeatmapData
): { totalScore: number; averageScore: number; minScore: number } => {
  if (path.length === 0) {
    return { totalScore: 0, averageScore: 50, minScore: 50 };
  }

  const scores = path.map((point) =>
    getSafetyScoreAtLocation(point.lat(), point.lng(), heatmapData)
  );

  const totalScore = scores.reduce((sum, score) => sum + score, 0);
  const averageScore = totalScore / scores.length;
  const minScore = Math.min(...scores);

  return { totalScore, averageScore, minScore };
};

/**
 * Find safer waypoints by avoiding low-safety tiles
 */
export const findSafeWaypoints = (
  origin: { lat: number; lng: number },
  destination: { lat: number; lng: number },
  heatmapData: HeatmapData,
  numWaypoints: number = 3
): google.maps.LatLng[] => {
  const waypoints: google.maps.LatLng[] = [];
  
  // Simple approach: divide route into segments and find safer points
  for (let i = 1; i <= numWaypoints; i++) {
    const t = i / (numWaypoints + 1);
    const baseLat = origin.lat + (destination.lat - origin.lat) * t;
    const baseLng = origin.lng + (destination.lng - origin.lng) * t;
    
    // Search nearby for a safer location
    const searchRadius = 0.002; // ~200m
    let bestLat = baseLat;
    let bestLng = baseLng;
    let bestScore = getSafetyScoreAtLocation(baseLat, baseLng, heatmapData);
    
    // Check surrounding points
    for (let offsetLat = -searchRadius; offsetLat <= searchRadius; offsetLat += 0.001) {
      for (let offsetLng = -searchRadius; offsetLng <= searchRadius; offsetLng += 0.001) {
        const testLat = baseLat + offsetLat;
        const testLng = baseLng + offsetLng;
        const score = getSafetyScoreAtLocation(testLat, testLng, heatmapData);
        
        if (score > bestScore) {
          bestScore = score;
          bestLat = testLat;
          bestLng = testLng;
        }
      }
    }
    
    waypoints.push(new google.maps.LatLng(bestLat, bestLng));
  }
  
  return waypoints;
};

/**
 * Load pre-processed lighting heatmap grid data
 * This data should be generated by running: node src/lib/processLightingData.js
 */
export const processLightingDataToGrid = async (): Promise<LightingHeatmapData> => {
  try {
    // Load pre-processed lighting grid data
    const response = await fetch('/data/lighting-grid.json');
    if (response.ok) {
      const data = await response.json();
      return {
        ...data,
        cells: data.cells.map((cell: any) => ({
          ...cell,
          lightingScore: cell.lightingScore || (100 - cell.percentile * 0.9),
          opacity: cell.opacity || 0.5,
        })),
      };
    }
  } catch (error) {
    console.warn('Could not load lighting-grid.json:', error);
  }

  // Return empty grid if loading fails
  return {
    gridSize: 0.005,
    cells: [],
    bounds: { latMin: 43.58, latMax: 43.85, lngMin: -79.64, lngMax: -79.12 },
  };
};

/**
 * Get lighting score for a specific lat/lng coordinate
 */
export const getLightingScoreAtLocation = (
  lat: number,
  lng: number,
  lightingData: LightingHeatmapData
): number => {
  const cell = lightingData.cells.find(
    (c) =>
      lat >= c.latMin &&
      lat < c.latMax &&
      lng >= c.lngMin &&
      lng < c.lngMax
  );
  
  return cell?.lightingScore ?? 50; // Default to medium lighting if not found
};

/**
 * Route scoring interface
 */
export interface RouteScore {
  route: google.maps.DirectionsRoute;
  distance: number; // in meters
  duration: number; // in seconds
  crimeSafetyScore: number; // 0-100, higher is safer
  lightingScore: number; // 0-100, higher is better lit
  combinedSafetyScore: number; // 0-100, weighted combination
  minSafetyScore: number; // worst point along route
}

/**
 * Score a route using both crime and lighting heatmaps
 * Returns a comprehensive safety score
 */
export const scoreRoute = (
  route: google.maps.DirectionsRoute,
  crimeHeatmap: HeatmapData | null,
  lightingHeatmap: LightingHeatmapData | null
): RouteScore => {
  // Extract path from route - handle both overview_path and step paths
  const path: google.maps.LatLng[] = [];
  
  // Try to use overview_path first (faster, less detailed)
  if (route.overview_path && route.overview_path.length > 0) {
    route.overview_path.forEach((point) => {
      path.push(point);
    });
  } else if (route.legs && route.legs.length > 0) {
    // Fallback to step-by-step path
    route.legs.forEach((leg) => {
      if (leg.steps) {
        leg.steps.forEach((step) => {
          if (step.path) {
            step.path.forEach((point) => {
              path.push(point);
            });
          }
        });
      }
    });
  }

  // Calculate distance and duration
  let totalDistance = 0;
  let totalDuration = 0;
  route.legs.forEach((leg) => {
    totalDistance += leg.distance?.value || 0;
    totalDuration += leg.duration?.value || 0;
  });

  // Score based on crime heatmap
  // Use weighted average that penalizes dangerous areas more heavily
  let crimeSafetyScore = 50; // Default if no data
  let minCrimeScore = 50;
  if (crimeHeatmap && path.length > 0) {
    const crimeScores = path.map((point) =>
      getSafetyScoreAtLocation(point.lat(), point.lng(), crimeHeatmap)
    );
    
    // Use a non-linear transformation to emphasize differences
    // Lower scores get penalized more, higher scores get rewarded more
    const transformedScores = crimeScores.map(score => {
      if (score >= 80) {
        // Boost safe areas (80-100 -> 85-100)
        return 85 + (score - 80) * 0.75;
      } else if (score >= 50) {
        // Moderate areas stay roughly the same
        return score;
      } else {
        // Penalize dangerous areas more (0-50 -> 0-40)
        return score * 0.8;
      }
    });
    
    // Weighted average: give more weight to worst segments
    const weights = crimeScores.map(score => {
      // Lower scores get higher weight (more important to avoid)
      return 100 - score;
    });
    const totalWeight = weights.reduce((sum, w) => sum + w, 0);
    
    if (totalWeight > 0) {
      crimeSafetyScore = transformedScores.reduce((sum, score, i) => 
        sum + score * (weights[i] / totalWeight), 0
      );
    } else {
      crimeSafetyScore = transformedScores.reduce((sum, score) => sum + score, 0) / transformedScores.length;
    }
    
    minCrimeScore = Math.min(...crimeScores);
  }

  // Score based on lighting heatmap
  let lightingScore = 50; // Default if no data
  if (lightingHeatmap && path.length > 0) {
    const lightingScores = path.map((point) =>
      getLightingScoreAtLocation(point.lat(), point.lng(), lightingHeatmap)
    );
    lightingScore = lightingScores.reduce((sum, score) => sum + score, 0) / lightingScores.length;
  }

  // Combined safety score: 70% crime safety, 30% lighting
  // Increased crime weight to make it more impactful
  // Apply non-linear scaling to further differentiate routes
  let combinedSafetyScore = crimeHeatmap && lightingHeatmap
    ? crimeSafetyScore * 0.7 + lightingScore * 0.3
    : crimeHeatmap
    ? crimeSafetyScore
    : lightingHeatmap
    ? lightingScore
    : 50;
  
  // Apply exponential scaling to create more dramatic differences
  // Safe routes (70+) get boosted, dangerous routes (30-) get penalized more
  if (combinedSafetyScore >= 70) {
    // Boost safe routes: 70-100 -> 75-100
    combinedSafetyScore = 75 + (combinedSafetyScore - 70) * 0.83;
  } else if (combinedSafetyScore >= 40) {
    // Moderate routes stay similar
    combinedSafetyScore = combinedSafetyScore;
  } else {
    // Penalize dangerous routes more: 0-40 -> 0-30
    combinedSafetyScore = combinedSafetyScore * 0.75;
  }
  
  // Ensure score stays in 0-100 range
  combinedSafetyScore = Math.max(0, Math.min(100, combinedSafetyScore));

  return {
    route,
    distance: totalDistance,
    duration: totalDuration,
    crimeSafetyScore,
    lightingScore,
    combinedSafetyScore,
    minSafetyScore: minCrimeScore,
  };
};

/**
 * Compare multiple routes and identify shortest, safest, and balanced
 */
export interface RouteComparison {
  routes: RouteScore[];
  shortest: RouteScore | null;
  safest: RouteScore | null;
  balanced: RouteScore | null;
}

export const compareRoutes = (
  routes: google.maps.DirectionsRoute[],
  crimeHeatmap: HeatmapData | null,
  lightingHeatmap: LightingHeatmapData | null
): RouteComparison => {
  if (routes.length === 0) {
    return { routes: [], shortest: null, safest: null, balanced: null };
  }

  // Score all routes
  const scoredRoutes = routes.map((route) => scoreRoute(route, crimeHeatmap, lightingHeatmap));

  // Find shortest route (by distance)
  const shortest = scoredRoutes.reduce((prev, curr) =>
    curr.distance < prev.distance ? curr : prev
  );

  // Find safest route (by combined safety score)
  const safest = scoredRoutes.reduce((prev, curr) =>
    curr.combinedSafetyScore > prev.combinedSafetyScore ? curr : prev
  );

  // Find balanced route (best trade-off between distance and safety)
  // Use a normalized score: (safety_score / 100) * 0.6 + (1 - normalized_distance) * 0.4
  // Normalize distance: 0 (longest) to 1 (shortest)
  const maxDistance = Math.max(...scoredRoutes.map((r) => r.distance));
  const minDistance = Math.min(...scoredRoutes.map((r) => r.distance));
  const balanced = scoredRoutes.reduce((prev, curr) => {
    // Normalize distance: 0 (longest) to 1 (shortest)
    const prevDistanceNorm = maxDistance > minDistance 
      ? 1 - (prev.distance - minDistance) / (maxDistance - minDistance)
      : 1;
    const currDistanceNorm = maxDistance > minDistance
      ? 1 - (curr.distance - minDistance) / (maxDistance - minDistance)
      : 1;
    
    // Combined score: higher is better
    const prevScore = (prev.combinedSafetyScore / 100) * 0.6 + prevDistanceNorm * 0.4;
    const currScore = (curr.combinedSafetyScore / 100) * 0.6 + currDistanceNorm * 0.4;
    return currScore > prevScore ? curr : prev;
  });

  return {
    routes: scoredRoutes,
    shortest,
    safest,
    balanced,
  };
};

